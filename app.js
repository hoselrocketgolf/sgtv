/*
  SimGolf TV Guide — lightweight static site
  Data source: schedule.json generated by GitHub Actions
*/

const JSON_URL = "./schedule.json";

const { DateTime } = luxon;
const TZ = "America/New_York";

// ---- Helpers ----
function norm(s){ return (s ?? "").toString().trim(); }
function escapeHtml(s){
  return norm(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function parseDateET(value){
  const v = norm(value);
  if (!v) return null;

  // ISO-like
  let dt = DateTime.fromISO(v, { zone: TZ });
  if (dt.isValid) return dt;

  // our format: yyyy-LL-dd HH:mm
  dt = DateTime.fromFormat(v, "yyyy-LL-dd HH:mm", { zone: TZ });
  if (dt.isValid) return dt;

  return null;
}
function fmtTime(dt){ return dt.setZone(TZ).toFormat("h:mm a"); }
function fmtDate(dt){ return dt.setZone(TZ).toFormat("ccc, LLL d"); }

// ---- UI ----
const leagueFilter = document.getElementById("leagueFilter");
const platformFilter = document.getElementById("platformFilter");
const searchBox = document.getElementById("searchBox");
const refreshBtn = document.getElementById("refreshBtn");

const nowBody = document.getElementById("nowBody");
const nextBody = document.getElementById("nextBody");
const nowPill = document.getElementById("nowPill");

const scheduleCards = document.getElementById("scheduleCards");
const emptyMsg = document.getElementById("emptyMsg");
const lastUpdated = document.getElementById("lastUpdated");

let allEvents = [];

// ---- Filters ----
function buildOption(selectEl, values){
  const current = selectEl.value;
  while (selectEl.options.length > 1) selectEl.remove(1);
  [...values].sort((a,b)=>a.localeCompare(b)).forEach(v=>{
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    selectEl.appendChild(opt);
  });
  if ([...selectEl.options].some(o=>o.value===current)) selectEl.value = current;
}

function rowMatchesFilters(evt){
  const lf = leagueFilter.value;
  const pf = platformFilter.value;
  const q = norm(searchBox.value).toLowerCase();

  if (lf && norm(evt.league) !== lf) return false;
  if (pf && norm(evt.platform) !== pf) return false;

  if (q){
    const hay = [evt.title, evt.league, evt.platform, evt.channel]
      .map(x=>norm(x).toLowerCase()).join(" ");
    if (!hay.includes(q)) return false;
  }
  return true;
}

// ---- Cards ----
function setCard(el, evt, label){
  if (!evt){
    el.innerHTML = `<p class="muted">No ${label.toLowerCase()} event.</p>`;
    return;
  }

  const start = evt.start;
  const end = evt.end;
  const timeLine = end ? `${fmtTime(start)}–${fmtTime(end)} ET` : `${fmtTime(start)} ET`;
  const subLine = `${fmtDate(start)} • ${escapeHtml(evt.platform || "—")} • ${escapeHtml(evt.channel || "—")}`;

  const thumb = evt.thumbnail_url
    ? `<img src="${evt.thumbnail_url}" alt="" style="width:100%;border-radius:14px;border:1px solid rgba(255,255,255,0.08);margin-bottom:10px;">`
    : "";

  const watch = evt.watch_url
    ? `<a href="${evt.watch_url}" target="_blank" rel="noopener">Watch</a>`
    : `<span class="muted">No link</span>`;

  const livePill = evt.status === "live"
    ? `<span class="pill live" style="margin-left:8px;">LIVE</span>`
    : "";

  el.innerHTML = `
    ${thumb}
    <div class="title" style="font-weight:900;font-size:15px;margin-bottom:6px;">
      ${escapeHtml(evt.title || "Untitled")} ${livePill}
    </div>
    <div class="muted" style="margin-bottom:10px;">${timeLine}</div>
    <div class="muted small" style="margin-bottom:10px;">${subLine}</div>
    <div class="watch">${watch}</div>
  `;
}

// ---- Sorting / selecting ----
function computeNowNext(events){
  const now = DateTime.now().setZone(TZ);

  // live if status says live OR within [start, start+2h] fallback
  const live = events.filter(e=>{
    if (!e.start) return false;
    if (e.status === "live") return true;
    const end = e.end ?? e.start.plus({ hours: 2 });
    return now >= e.start && now <= end;
  });

  // prefer higher subs if multiple live
  live.sort((a,b)=> (b.subscribers||0)-(a.subscribers||0));

  const upcoming = events.filter(e=>e.start && e.start > now && e.status !== "live");
  upcoming.sort((a,b)=>{
    const d = a.start.toMillis() - b.start.toMillis();
    if (d !== 0) return d;
    return (b.subscribers||0)-(a.subscribers||0);
  });

  return {
    nowEvt: live[0] || null,
    nextEvt: upcoming[0] || null,
    isLive: live.length > 0
  };
}

// ---- Render ----
function render(){
  const filtered = allEvents.filter(rowMatchesFilters);

  const { nowEvt, nextEvt, isLive } = computeNowNext(filtered);
  nowPill.hidden = !isLive;

  setCard(nowBody, nowEvt, "Now");
  setCard(nextBody, nextEvt, "Next");

  // Guide: LIVE first, then next 50 upcoming
  const now = DateTime.now().setZone(TZ);

  const live = filtered
    .filter(e => e.status === "live")
    .sort((a,b)=> (b.subscribers||0)-(a.subscribers||0));

  const upcoming = filtered
    .filter(e => e.start && e.start > now && e.status !== "live")
    .sort((a,b)=>{
      const d = a.start.toMillis() - b.start.toMillis();
      if (d !== 0) return d;
      return (b.subscribers||0)-(a.subscribers||0);
    })
    .slice(0, 50);

  const guide = [...live, ...upcoming];

  scheduleCards.innerHTML = "";

  if (guide.length === 0){
    emptyMsg.hidden = false;
    scheduleCards.innerHTML = `<div class="muted">No LIVE or upcoming events found (try clearing filters).</div>`;
    return;
  }

  emptyMsg.hidden = true;

  guide.forEach(evt => {
    const card = document.createElement("div");
    card.className = `eventCard ${evt.status === "live" ? "live" : ""}`;

    const timeLine = evt.start
      ? `${fmtTime(evt.start)} ET • ${fmtDate(evt.start)}`
      : "";

    const subsLine = evt.subscribers
      ? `<span class="metaPill">${evt.subscribers.toLocaleString()} subs</span>`
      : "";

    const watch = evt.watch_url
      ? `<a href="${evt.watch_url}" target="_blank" rel="noopener">Watch</a>`
      : `<span class="muted">No link</span>`;

    const thumb = evt.thumbnail_url
      ? `<img src="${evt.thumbnail_url}" alt="" style="width:100%;border-radius:14px;border:1px solid rgba(255,255,255,0.08);">`
      : "";

    card.innerHTML = `
      ${thumb}
      <div class="eventTime">${escapeHtml(timeLine)}</div>
      <div class="eventTitle">${escapeHtml(evt.title || "Untitled")}</div>
      <div class="eventMeta">
        ${evt.status === "live" ? `<span class="metaPill live">LIVE</span>` : ``}
        ${evt.platform ? `<span class="metaPill">${escapeHtml(evt.platform)}</span>` : ``}
        ${evt.channel ? `<span class="metaPill">${escapeHtml(evt.channel)}</span>` : ``}
        ${subsLine}
      </div>
      <div class="eventActions">${watch}</div>
    `;

    scheduleCards.appendChild(card);
  });
}

async function load(){
  scheduleCards.innerHTML = `<div class="muted">Loading…</div>`;
  emptyMsg.hidden = true;

  const res = await fetch(JSON_URL, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to load schedule.json (${res.status})`);

  const data = await res.json();

  const events = [];
  for (const r of data){
    const start = parseDateET(r.start_et);
    const end = parseDateET(r.end_et);

    if (!start) continue;

    events.push({
      start, end,
      title: r.title || "",
      league: r.league || "",
      platform: r.platform || "YouTube",
      channel: r.channel || "",
      watch_url: r.watch_url || "",
      source_id: r.source_id || "",
      status: r.status || "",
      thumbnail_url: r.thumbnail_url || "",
      subscribers: Number(r.subscribers || 0)
    });
  }

  allEvents = events;

  const leagues = new Set(allEvents.map(e=>norm(e.league)).filter(Boolean));
  const plats = new Set(allEvents.map(e=>norm(e.platform)).filter(Boolean));
  buildOption(leagueFilter, leagues);
  buildOption(platformFilter, plats);

  lastUpdated.textContent = `Last updated: ${DateTime.now().setZone(TZ).toFormat("LLL d, yyyy h:mm a")} ET`;

  render();
}

function wire(){
  leagueFilter.addEventListener("change", render);
  platformFilter.addEventListener("change", render);
  searchBox.addEventListener("input", () => {
    window.clearTimeout(window.__qT);
    window.__qT = window.setTimeout(render, 120);
  });
  refreshBtn.addEventListener("click", () => {
    refreshBtn.textContent = "Updating…";
    refreshBtn.disabled = true;
    load()
      .catch(err => {
        alert(err.message);
        console.error(err);
      })
      .finally(()=>{
        refreshBtn.textContent = "Update";
        refreshBtn.disabled = false;
      });
  });

  setInterval(()=>load().catch(()=>{}), 5 * 60 * 1000);
}

wire();
load().catch(err => {
  nowBody.innerHTML = `<p class="muted">Could not load schedule.</p><p class="muted small">${escapeHtml(err.message)}</p>`;
  nextBody.innerHTML = `<p class="muted">—</p>`;
  scheduleCards.innerHTML = `<div class="muted">Could not load schedule: ${escapeHtml(err.message)}</div>`;
  console.error(err);
});
