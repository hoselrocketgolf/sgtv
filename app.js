/* app.js — FULL REPLACEMENT
   SimGolf TV Guide
   - Fetches schedule.json
   - Renders Now On, Up Next
   - Replaces "How it works" tile with a horizontal time scroller (TV Guide style)
   - Keeps thumbnails
*/

const DATA_URL = "./schedule.json"; // generated by your GitHub Action

// ---------- Time helpers (ET) ----------
function etNow() {
  // Your data times are ET strings, and the site says "Times in Eastern".
  // We'll compute "now" in ET using Intl.
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(new Date());
  const get = (t) => parts.find((p) => p.type === t)?.value || "";
  const y = get("year");
  const m = get("month");
  const d = get("day");
  const hh = get("hour");
  const mm = get("minute");
  return new Date(`${y}-${m}-${d}T${hh}:${mm}:00`);
}

function parseEtString(etStr) {
  // Expects "YYYY-MM-DD HH:mm"
  if (!etStr) return null;
  const s = etStr.trim().replace(" ", "T");
  const dt = new Date(s);
  return isNaN(dt.getTime()) ? null : dt;
}

function formatTimeEt(d) {
  if (!d) return "";
  return new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    hour: "numeric",
    minute: "2-digit",
  }).format(d);
}

function formatDayEt(d) {
  if (!d) return "";
  return new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    weekday: "short",
    month: "short",
    day: "numeric",
  }).format(d);
}

function clampToHalfHour(d) {
  const dd = new Date(d);
  const mins = dd.getMinutes();
  dd.setSeconds(0, 0);
  dd.setMinutes(mins < 30 ? 0 : 30);
  return dd;
}

function addMinutes(d, mins) {
  const dd = new Date(d);
  dd.setMinutes(dd.getMinutes() + mins);
  return dd;
}

function sameEtDate(a, b) {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return fmt.format(a) === fmt.format(b);
}

// ---------- Data normalization ----------
function normalizeEvent(e) {
  const start = parseEtString(e.start_et);
  const end = parseEtString(e.end_et);

  const status = (e.status || "").toLowerCase();
  const subscribers = Number(e.subscribers || 0) || 0;

  // If live and no start time, treat as now (shouldn't happen much, but safe)
  const startSafe = start || etNow();

  // Some upcoming may not have end; we treat as "starts at"
  // For overlap checks, we'll treat end as start+2h for upcoming to give it a block feel,
  // but only for display filtering windows (not displayed as actual end time).
  const endFallback = status === "live" ? addMinutes(startSafe, 120) : addMinutes(startSafe, 120);

  const endSafe = end || endFallback;

  // Prefer thumbnail_url, otherwise YouTube hq default
  let thumb = e.thumbnail_url || "";
  if (!thumb && e.source_id) {
    thumb = `https://i.ytimg.com/vi/${e.source_id}/hqdefault.jpg`;
  }

  return {
    ...e,
    status,
    subscribers,
    start_dt: startSafe,
    end_dt: endSafe,
    thumbnail_url: thumb,
    channel: e.channel || "",
    title: e.title || "",
    platform: e.platform || "",
    watch_url: e.watch_url || "",
  };
}

function sortEvents(events) {
  // LIVE first, then by time, tie by subscribers desc
  return [...events].sort((a, b) => {
    const ar = a.status === "live" ? 0 : 1;
    const br = b.status === "live" ? 0 : 1;
    if (ar !== br) return ar - br;

    const at = a.start_dt.getTime();
    const bt = b.start_dt.getTime();
    if (at !== bt) return at - bt;

    return (b.subscribers || 0) - (a.subscribers || 0);
  });
}

// ---------- UI ----------
function el(tag, attrs = {}, children = []) {
  const n = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
    if (k === "class") n.className = v;
    else if (k === "html") n.innerHTML = v;
    else if (k.startsWith("on") && typeof v === "function") n.addEventListener(k.slice(2), v);
    else n.setAttribute(k, v);
  }
  for (const c of children) {
    if (c == null) continue;
    if (typeof c === "string") n.appendChild(document.createTextNode(c));
    else n.appendChild(c);
  }
  return n;
}

function badge(text, extraClass = "") {
  return el("span", { class: `badge ${extraClass}` }, [text]);
}

function eventCard(e, { compact = false } = {}) {
  const topLine = `${formatDayEt(e.start_dt)} • ${e.platform}${e.channel ? " • " + e.channel : ""}`;
  const timeLine =
    e.status === "live"
      ? `${formatTimeEt(e.start_dt)} ET`
      : `${formatTimeEt(e.start_dt)} ET`;

  const statusPill =
    e.status === "live"
      ? badge("LIVE", "badge-live")
      : e.status === "upcoming"
      ? badge("UPCOMING", "badge-upcoming")
      : null;

  const img = el("img", {
    class: "thumb",
    src: e.thumbnail_url || "",
    alt: e.title || "",
    loading: "lazy",
  });

  const title = el("div", { class: compact ? "event-title compact" : "event-title" }, [e.title || "Untitled"]);
  const meta = el("div", { class: "event-meta" }, [topLine]);
  const time = el("div", { class: "event-time" }, [timeLine]);

  const watch = el(
    "a",
    { class: compact ? "btn btn-watch compact" : "btn btn-watch", href: e.watch_url || "#", target: "_blank", rel: "noopener" },
    ["Watch"]
  );

  const subs =
    e.subscribers && e.subscribers > 0
      ? el("div", { class: "event-subs" }, [`${e.subscribers.toLocaleString()} subs`])
      : null;

  const left = el("div", { class: "event-left" }, [img]);
  const right = el("div", { class: "event-right" }, [
    el("div", { class: "event-row1" }, [
      title,
      statusPill ? el("div", { class: "event-pillwrap" }, [statusPill]) : null,
    ]),
    time,
    meta,
    subs,
    watch,
  ]);

  return el("div", { class: compact ? "event-card compact" : "event-card" }, [left, right]);
}

function emptyCard(text) {
  return el("div", { class: "empty" }, [text]);
}

// ---------- TV Guide-ish time scroller ----------
function buildTimeScroller(events, state) {
  // state.slotStart is a Date (ET-local) rounded to :00 or :30
  const slotMinutes = 30;
  const numSlots = 7; // like your TVGuide-ish screenshot: shows a short strip
  const windowMinutes = slotMinutes; // the “active” window is one slot (30 min)
  const stripMinutes = slotMinutes * (numSlots - 1);

  const stripStart = addMinutes(state.slotStart, -slotMinutes * 2); // show a bit before
  const stripEnd = addMinutes(stripStart, slotMinutes * (numSlots - 1));

  const headerRow = el("div", { class: "tvstrip-header" }, []);

  const leftBtn = el("button", { class: "tvstrip-arrow", onClick: () => {
    state.slotStart = addMinutes(state.slotStart, -slotMinutes);
    render(state);
  }}, ["←"]);

  const rightBtn = el("button", { class: "tvstrip-arrow", onClick: () => {
    state.slotStart = addMinutes(state.slotStart, slotMinutes);
    render(state);
  }}, ["→"]);

  const slotsWrap = el("div", { class: "tvstrip-slots" }, []);
  const now = etNow();

  for (let i = 0; i < numSlots; i++) {
    const t = addMinutes(stripStart, i * slotMinutes);
    const isActive = t.getTime() === state.slotStart.getTime();
    const isNow =
      now.getTime() >= t.getTime() && now.getTime() < addMinutes(t, slotMinutes).getTime() && sameEtDate(now, t);

    const btn = el("button", {
      class: `tvslot ${isActive ? "active" : ""} ${isNow ? "now" : ""}`,
      onClick: () => {
        state.slotStart = t;
        render(state);
      }
    }, [formatTimeEt(t)]);
    slotsWrap.appendChild(btn);
  }

  headerRow.appendChild(leftBtn);
  headerRow.appendChild(slotsWrap);
  headerRow.appendChild(rightBtn);

  // Filter: events that overlap the active slot window (or are live right now)
  const slotEnd = addMinutes(state.slotStart, windowMinutes);

  const overlap = (e) => {
    if (!sameEtDate(e.start_dt, state.today)) return false; // today-only view
    if (e.status === "live") {
      // show live if it's live "now" (not just flagged live but in future)
      return true;
    }
    // Upcoming: show if it starts within the slot, OR overlaps the slot
    return e.start_dt.getTime() < slotEnd.getTime() && e.end_dt.getTime() > state.slotStart.getTime();
  };

  const list = sortEvents(events.filter(overlap));

  const listWrap = el("div", { class: "tvlist" }, []);
  if (!list.length) {
    listWrap.appendChild(emptyCard("No streams in this time slot."));
  } else {
    for (const e of list) {
      // For upcoming, show exact start time; for live show LIVE pill
      listWrap.appendChild(eventCard(e, { compact: true }));
    }
  }

  const titleRow = el("div", { class: "tvstrip-title" }, [
    el("div", { class: "tvstrip-title-left" }, [
      el("div", { class: "tvstrip-h1" }, ["Today's Schedule"]),
      el("div", { class: "tvstrip-h2" }, [
        `${formatDayEt(state.today)} • slot: ${formatTimeEt(state.slotStart)}–${formatTimeEt(slotEnd)} ET`
      ])
    ]),
    el("div", { class: "tvstrip-title-right" }, [
      el("div", { class: "tvstrip-tip" }, ["Tip: click a time or use arrows"])
    ])
  ]);

  return el("div", { class: "tvstrip" }, [titleRow, headerRow, listWrap]);
}

// ---------- Main render ----------
async function fetchEvents() {
  const bust = `?t=${Date.now()}`;
  const res = await fetch(DATA_URL + bust, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to load schedule.json (${res.status})`);
  const data = await res.json();
  return Array.isArray(data) ? data.map(normalizeEvent) : [];
}

function filterByUI(events, state) {
  let out = events;

  // league filter (if used later)
  if (state.filters.league && state.filters.league !== "All") {
    out = out.filter((e) => (e.league || "") === state.filters.league);
  }

  // platform filter
  if (state.filters.platform && state.filters.platform !== "All") {
    out = out.filter((e) => (e.platform || "") === state.filters.platform);
  }

  // search
  const q = (state.filters.search || "").trim().toLowerCase();
  if (q) {
    out = out.filter((e) =>
      (e.title || "").toLowerCase().includes(q) ||
      (e.channel || "").toLowerCase().includes(q) ||
      (e.league || "").toLowerCase().includes(q) ||
      (e.platform || "").toLowerCase().includes(q)
    );
  }

  return out;
}

function pickNowAndNext(events, state) {
  const now = etNow();

  // Consider "live" as now-on first
  const liveNow = events.find((e) => e.status === "live");
  if (liveNow) return { nowOn: liveNow, upNext: pickNext(events, now, liveNow) };

  // Otherwise nowOn = first upcoming that starts soon (within last 30 mins)?? or none
  const upcoming = events
    .filter((e) => e.status === "upcoming")
    .sort((a, b) => a.start_dt - b.start_dt);

  const next = upcoming.find((e) => e.start_dt.getTime() >= now.getTime());
  return { nowOn: null, upNext: next || null };
}

function pickNext(events, now, exclude) {
  const upcoming = events
    .filter((e) => e.status === "upcoming" && e.source_id !== exclude?.source_id)
    .sort((a, b) => a.start_dt - b.start_dt);
  return upcoming.find((e) => e.start_dt.getTime() >= now.getTime()) || upcoming[0] || null;
}

function buildTopControls(state, allEvents) {
  // derive options
  const platforms = ["All", ...Array.from(new Set(allEvents.map((e) => e.platform).filter(Boolean))).sort()];

  const platformSelect = el("select", {
    class: "control",
    onChange: (ev) => {
      state.filters.platform = ev.target.value;
      render(state);
    }
  }, platforms.map((p) => el("option", { value: p, ...(p === state.filters.platform ? { selected: "selected" } : {}) }, [p])));

  // League kept but optional; your data often blank. We'll keep the UI consistent.
  const leagues = ["All", ...Array.from(new Set(allEvents.map((e) => e.league).filter(Boolean))).sort()];
  const leagueSelect = el("select", {
    class: "control",
    onChange: (ev) => {
      state.filters.league = ev.target.value;
      render(state);
    }
  }, leagues.map((l) => el("option", { value: l, ...(l === state.filters.league ? { selected: "selected" } : {}) }, [l])));

  const search = el("input", {
    class: "control control-search",
    type: "text",
    placeholder: "Search title, league, channel…",
    value: state.filters.search || "",
    onInput: (ev) => {
      state.filters.search = ev.target.value;
      render(state, { soft: true });
    }
  });

  const refreshBtn = el("button", {
    class: "btn btn-refresh",
    onClick: async () => {
      state.loading = true;
      render(state);
      try {
        state.rawEvents = await fetchEvents();
      } catch (e) {
        state.error = e?.message || String(e);
      } finally {
        state.loading = false;
        state.lastUpdated = new Date();
        render(state);
      }
    }
  }, ["Update"]);

  return el("div", { class: "topbar" }, [
    el("div", { class: "control-group" }, [
      el("div", { class: "control-label" }, ["League"]),
      leagueSelect
    ]),
    el("div", { class: "control-group" }, [
      el("div", { class: "control-label" }, ["Platform"]),
      platformSelect
    ]),
    el("div", { class: "control-group control-group-grow" }, [
      el("div", { class: "control-label" }, ["Search"]),
      search
    ]),
    el("div", { class: "control-group" }, [
      el("div", { class: "control-label" }, ["Refresh"]),
      refreshBtn
    ]),
  ]);
}

function buildHeroTiles(state, filteredEvents) {
  const { nowOn, upNext } = pickNowAndNext(filteredEvents, state);

  const nowTile = el("div", { class: "tile tile-now" }, [
    el("div", { class: "tile-header" }, [
      el("div", { class: "tile-title" }, ["Now On"]),
      badge("LIVE", "badge-live")
    ]),
    nowOn ? eventCard(nowOn) : emptyCard("No live event right now.")
  ]);

  const nextTile = el("div", { class: "tile tile-next" }, [
    el("div", { class: "tile-header" }, [
      el("div", { class: "tile-title" }, ["Up Next"]),
    ]),
    upNext ? eventCard(upNext) : emptyCard("No upcoming events found.")
  ]);

  // REPLACEMENT for "How it works" tile: TV Guide time scroller
  const scrollerTile = el("div", { class: "tile tile-tv" }, [
    buildTimeScroller(filteredEvents, state)
  ]);

  return el("div", { class: "hero-grid" }, [nowTile, nextTile, scrollerTile]);
}

function buildScheduleGrid(state, filteredEvents) {
  // Show today's events in card grid below (keep your existing “today schedule” feel)
  const today = state.today;
  const todays = sortEvents(
    filteredEvents.filter((e) => sameEtDate(e.start_dt, today) || (e.status === "live" && sameEtDate(etNow(), today)))
  );

  const header = el("div", { class: "section-header" }, [
    el("div", { class: "section-title" }, ["Today's Schedule"]),
    el("div", { class: "section-sub" }, [
      state.lastUpdated
        ? `Last updated: ${new Intl.DateTimeFormat("en-US", {
            timeZone: "America/New_York",
            month: "short",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "2-digit",
          }).format(state.lastUpdated)} ET`
        : ""
    ])
  ]);

  const grid = el("div", { class: "cards-grid" }, []);
  if (!todays.length) {
    grid.appendChild(emptyCard("No events today."));
  } else {
    for (const e of todays) {
      grid.appendChild(eventCard(e));
    }
  }

  return el("div", { class: "section" }, [header, grid]);
}

function injectTvStripStyles() {
  // Minimal CSS additions so the time scroller looks right even if your CSS is older.
  // If you already have similar classes, these will just complement it.
  if (document.getElementById("tvstrip-style")) return;
  const css = `
  .tile-tv { overflow: hidden; }
  .tvstrip { display:flex; flex-direction:column; gap:12px; height:100%; }
  .tvstrip-title { display:flex; justify-content:space-between; align-items:flex-end; gap:10px; }
  .tvstrip-h1 { font-size: 18px; font-weight: 700; }
  .tvstrip-h2 { font-size: 12px; opacity: 0.75; margin-top: 2px; }
  .tvstrip-tip { font-size: 12px; opacity: 0.6; }
  .tvstrip-header { display:flex; align-items:center; gap:10px; }
  .tvstrip-arrow {
    width: 40px; height: 40px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
    color: inherit;
    cursor: pointer;
  }
  .tvstrip-arrow:hover { background: rgba(255,255,255,0.10); }
  .tvstrip-slots { display:flex; gap:8px; overflow:auto; padding-bottom: 4px; flex:1; }
  .tvslot {
    white-space: nowrap;
    padding: 10px 12px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    color: inherit;
    cursor: pointer;
    font-size: 13px;
  }
  .tvslot.active { background: rgba(66, 153, 225, 0.18); border-color: rgba(66,153,225,0.45); }
  .tvslot.now { box-shadow: 0 0 0 2px rgba(0,255,170,0.18) inset; }
  .tvlist { display:flex; flex-direction:column; gap:10px; overflow:auto; padding-right: 2px; }
  .event-card.compact { display:flex; gap:12px; padding: 10px; }
  .event-card.compact .thumb { width: 120px; height: 68px; object-fit: cover; border-radius: 12px; }
  .event-title.compact { font-size: 14px; font-weight: 700; line-height: 1.2; }
  .btn.btn-watch.compact { padding: 8px 10px; font-size: 13px; }
  `;
  const style = document.createElement("style");
  style.id = "tvstrip-style";
  style.textContent = css;
  document.head.appendChild(style);
}

let renderTimer = null;
function render(state, opts = {}) {
  // opts.soft means don't re-fetch, just re-render
  injectTvStripStyles();

  const root = document.getElementById("app") || document.body;
  root.innerHTML = "";

  const header = el("div", { class: "header" }, [
    el("div", { class: "brand" }, [
      el("div", { class: "brand-badge" }, ["SG"]),
      el("div", {}, [
        el("div", { class: "brand-title" }, ["SimGolf TV Guide"]),
        el("div", { class: "brand-sub" }, ["LIVE 24/7 • matches, leagues, and streams • Times in Eastern"])
      ])
    ]),
  ]);

  if (state.error) {
    root.appendChild(el("div", { class: "error" }, [state.error]));
  }

  if (state.loading) {
    root.appendChild(header);
    root.appendChild(el("div", { class: "loading" }, ["Loading…"]));
    return;
  }

  const allEvents = state.rawEvents || [];
  const filtered = filterByUI(allEvents, state);

  const controls = buildTopControls(state, allEvents);
  const hero = buildHeroTiles(state, filtered);
  const schedule = buildScheduleGrid(state, filtered);

  root.appendChild(header);
  root.appendChild(controls);
  root.appendChild(hero);
  root.appendChild(schedule);

  // Optional: auto-refresh UI every 60s (does not refetch)
  if (!renderTimer) {
    renderTimer = setInterval(() => {
      // keep the time scroller "now" feeling alive (without network)
      // but don't override user's chosen slot.
      // If they haven't interacted in a while, you can optionally snap back — leaving as-is.
      // We'll just re-render to update "now" highlighting.
      render(state, { soft: true });
    }, 60_000);
  }
}

// ---------- Boot ----------
(async function boot() {
  const state = {
    rawEvents: [],
    loading: true,
    error: "",
    lastUpdated: null,
    filters: {
      league: "All",
      platform: "All",
      search: ""
    },
    today: etNow(),
    slotStart: clampToHalfHour(etNow()),
  };

  render(state);

  try {
    state.rawEvents = await fetchEvents();
    state.lastUpdated = new Date();
  } catch (e) {
    state.error = e?.message || String(e);
  } finally {
    state.loading = false;
    render(state);
  }
})();
